<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Posts on &lt;/&gt;</title>
    <link>https://quxiaowei.github.io/post/</link>
    <description>Recent content in Posts on &lt;/&gt;</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-cn</language>
    <lastBuildDate>Tue, 19 Jul 2016 00:00:00 +0000</lastBuildDate>
    <atom:link href="https://quxiaowei.github.io/post/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>ABAP 调用 RESTful Web Service</title>
      <link>https://quxiaowei.github.io/post/abap_call_restful_webservice/</link>
      <pubDate>Tue, 19 Jul 2016 00:00:00 +0000</pubDate>
      
      <guid>https://quxiaowei.github.io/post/abap_call_restful_webservice/</guid>
      <description>

&lt;hr /&gt;

&lt;h2 id=&#34;关于rest&#34;&gt;关于REST&lt;/h2&gt;

&lt;p&gt;REST 是基于 http 的 web service 架构，URL表示资源，http method: GET, POST, DELETE 等等，表示发送，收取，删除的动作。我们做的是调用，即从第三方接受资源，所以我们用 GET 就可以了。&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;SOAP 是另一种基于 http 的 web service 协议，不在本文范围内.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;以&lt;code&gt;http://example/credit/20160516/0000001880/1380&lt;/code&gt;为例，其中&lt;code&gt;20160516&lt;/code&gt;代表日期，&lt;code&gt;0000001880&lt;/code&gt;代表客户，&lt;code&gt;1380&lt;/code&gt;代表公司，这些是与 web service 发布者协商好，作为参数过去的。&lt;/p&gt;

&lt;hr /&gt;

&lt;h2 id=&#34;http调用&#34;&gt;http调用&lt;/h2&gt;

&lt;p&gt;abap 有许多发送 http GET 请求的方法。我用的是函数: &lt;code&gt;HTTP_GET&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-abap&#34;&gt;DATA: status(3) TYPE c ,
      url TYPE c LENGTH 200,
      error TYPE string.
        
DATA: response TYPE TABLE OF xtext100 WITH HEADER LINE, &amp;quot; 返回内容
      &amp;quot; http header
      response_headers TYPE TABLE OF text100 WITH HEADER LINE. 
        
url = |http://example/credit/{ p_datum }/{ p_customer }/{ p_company }| .

CALL FUNCTION &#39;HTTP_GET&#39;
  EXPORTING
    absolute_uri          = url    &amp;quot; url
    timeout               = 1      &amp;quot; 超时
  IMPORTING
    status_code           = status  &amp;quot; 200 404等网页状态状态
  TABLES
    response_entity_body  = response
    response_headers      = response_headers
  EXCEPTIONS
    connect_failed        = 1
    timeout               = 2
    internal_error        = 3
    tcpip_error           = 4
    data_error            = 5
    system_failure        = 6
    communication_failure = 7
    OTHERS                = 8.

IF sy-subrc EQ 0 AND status(1) EQ &#39;2&#39;.
  &amp;quot; 成功
ELSE.
  &amp;quot; 失败
ENDIF.
&lt;/code&gt;&lt;/pre&gt;

&lt;hr /&gt;

&lt;h2 id=&#34;decode&#34;&gt;Decode&lt;/h2&gt;

&lt;p&gt;返回的内容可能与 sap 不兼容，编码信息在 http 头里，那么需要转码。以常见的 UTF-8 为例，&lt;strong&gt;Decode 代码&lt;/strong&gt;：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-abap&#34;&gt;DATA conv TYPE REF TO cl_abap_conv_in_ce.
DATA buffer TYPE xstring.
DATA v_text TYPE string.&amp;quot;(100) TYPE c.
DATA v_text_t TYPE string.&amp;quot;(100) TYPE c.
  
conv = cl_abap_conv_in_ce=&amp;gt;create( encoding = &#39;UTF-8&#39; ).
LOOP AT response.
  buffer = response.
  TRY.
      conv-&amp;gt;convert(
            EXPORTING input = buffer
            IMPORTING data = v_text_t ).
      CONCATENATE v_text v_text_t INTO v_text.
    CATCH cx_sy_conversion_codepage 
          cx_sy_codepage_converter_init 
          cx_parameter_invalid_type.
      p_subrc = 4.
      p_message = &#39;转码失败！&#39;.
      RETURN.
  ENDTRY.
ENDLOOP.
&lt;/code&gt;&lt;/pre&gt;

&lt;hr /&gt;

&lt;h2 id=&#34;json映射到abap&#34;&gt;json映射到ABAP&lt;/h2&gt;

&lt;p&gt;Web Service 常见的返回内容格式有 xml 和 json 两种。本文以 json 为例，xml 的处理方法和 json 大致相同，只是 “转换”的写法不同。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;json 示例&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;[
  {
    &amp;quot;result&amp;quot;:0.0122,
    &amp;quot;errorCode&amp;quot;:&amp;quot;0&amp;quot;,
    &amp;quot;errorMessage&amp;quot;:&amp;quot;&amp;quot;
    }, 
  {
    &amp;quot;result&amp;quot;:2.01,
    &amp;quot;errorCode&amp;quot;:&amp;quot;0&amp;quot;,
    &amp;quot;errorMessage&amp;quot;:&amp;quot;&amp;quot;
  }
]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这是一个包含2个对象的数组（&lt;code&gt;[]&lt;/code&gt;包围），每个对象（&lt;code&gt;{}&lt;/code&gt;包围）中有三个字段： &lt;code&gt;result&lt;/code&gt;, &lt;code&gt;errorCode&lt;/code&gt;, &lt;code&gt;errorMessage&lt;/code&gt;。其中&lt;code&gt;result&lt;/code&gt;是数字型的（注意没有引号包围），其他均为字符串。与后面的转换对应着看。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;abap 代码&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-abap&#34;&gt;TYPES: BEGIN OF ty_result,
        result TYPE string,
        errorcode TYPE string,
        errormessage TYPE string,
       END OF ty_result.
DATA it_result TYPE TABLE OF ty_result.

TRY
    CALL TRANSFORMATION z_test_json1 SOURCE XML v_text
                                     RESULT out = it_result.
  CATCH cx_st_error cx_xslt_exception cx_transformation_error.
    &amp;quot; 解析json失败
ENDTRY.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;z_test_json1&lt;/code&gt; 是自定义的 “转换”，可以将 json 中的数据映射到 abap 内表或工作区里，因为过程涉及类型转换，所以需要 &lt;code&gt;try catch&lt;/code&gt; 来捕捉异常。“转换”完成后，json 中的数据就回被填入到 &lt;code&gt;it_result&lt;/code&gt;内表中，整个流程也就完成了。&lt;/p&gt;

&lt;hr /&gt;

&lt;h2 id=&#34;转换-写法&#34;&gt;“转换”写法&lt;/h2&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;创建“转换” &lt;img src=&#34;https://quxiaowei.github.io/img/transform1.png&#34; alt=&#34;创建“转换”&#34; /&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;转换类型选择“简单转换”&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;“转换”示例&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;pre&gt;&lt;code class=&#34;language-XML&#34;&gt;&amp;lt;?sap.transform simple?&amp;gt;
&amp;lt;tt:transform xmlns:tt=&amp;quot;http://www.sap.com/transformation-templates&amp;quot;&amp;gt;
  &amp;lt;tt:root name=&amp;quot;OUT&amp;quot;/&amp;gt;
  &amp;lt;tt:template&amp;gt;
    &amp;lt;array&amp;gt;
      &amp;lt;tt:loop ref=&amp;quot;.RESULT&amp;quot;&amp;gt;
        &amp;lt;object&amp;gt;
          &amp;lt;num name=&amp;quot;result&amp;quot;&amp;gt;
            &amp;lt;tt:value ref=&amp;quot;$ref.RESULT&amp;quot;/&amp;gt;
          &amp;lt;/num&amp;gt;
          &amp;lt;str name=&amp;quot;errorCode&amp;quot;&amp;gt;
            &amp;lt;tt:value ref=&amp;quot;$ref.ERRORCODE&amp;quot;/&amp;gt;
          &amp;lt;/str&amp;gt;
          &amp;lt;str name=&amp;quot;errorMessage&amp;quot;&amp;gt;
            &amp;lt;tt:value ref=&amp;quot;$ref.ERRORMESSAGE&amp;quot;/&amp;gt;
          &amp;lt;/str&amp;gt;
        &amp;lt;/object&amp;gt;
      &amp;lt;/tt:loop&amp;gt;
    &amp;lt;/array&amp;gt;
  &amp;lt;/tt:template&amp;gt;
&amp;lt;/tt:transform&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;code&gt;&amp;lt;array&amp;gt;&lt;/code&gt; 代表数组&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;code&gt;&amp;lt;object&amp;gt;&lt;/code&gt; 代表对象&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;code&gt;&amp;lt;tt:loop&amp;gt;&lt;/code&gt; 循环处理&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;code&gt;&amp;lt;num&amp;gt;&lt;/code&gt; 代表数字，如果有非法字符会报异常，所以转换过程需要用&lt;code&gt;try catch&lt;/code&gt;来捕捉异常&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;code&gt;&amp;lt;str&amp;gt;&lt;/code&gt; 代表字符串&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;code&gt;&amp;lt;tt:value&amp;gt;&lt;/code&gt; 的 &lt;code&gt;name&lt;/code&gt; 属性与表字段名对应，转换程序会，自动将值放到内表或工作区里。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;code&gt;&amp;lt;tt:root&amp;gt;&lt;/code&gt; 的 &lt;code&gt;name&lt;/code&gt; 为“转换”结果（RESULT）的形参名（本例为 out）&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>FFMPEG Cheatsheet</title>
      <link>https://quxiaowei.github.io/post/ffmpeg_cheatsheet/</link>
      <pubDate>Fri, 15 Jul 2016 00:00:00 +0000</pubDate>
      
      <guid>https://quxiaowei.github.io/post/ffmpeg_cheatsheet/</guid>
      <description>&lt;p&gt;&lt;code&gt;-vcodec&lt;/code&gt; &lt;code&gt;-acodec&lt;/code&gt; 视屏，音频编码 &lt;code&gt;copy&lt;/code&gt; 拷贝源文件&lt;/p&gt;

&lt;p&gt;合并视屏&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;ffmpeg -f concat -i buffer_list -c copy output.mkv
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;截取视频&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;ffmpeg -i source.avi -ss 00:01:35 -t 00:47:13 -vcodec copy output.mp4
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;-ss&lt;/code&gt; 开始时间 &lt;code&gt;-t&lt;/code&gt; 时长&lt;/p&gt;

&lt;p&gt;缩小视屏&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;ffmpeg -i a.mp4 -vf scale=853:480 -acodec acc -vcodec h264 out.mp4
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;裁剪视屏&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;ffmpeg -i a.mp5 -strict -2 -vf crop=1080:1080:0:420 out.mp4
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;crop=width:height:x:y&lt;/code&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Python 的 nested() 不见了</title>
      <link>https://quxiaowei.github.io/post/python_no_nested_anymore/</link>
      <pubDate>Thu, 14 Jul 2016 00:00:00 +0000</pubDate>
      
      <guid>https://quxiaowei.github.io/post/python_no_nested_anymore/</guid>
      <description>&lt;p&gt;最近在和别的系统测试 Rest Web Service 的接口，用 python 写了单元测试脚本 &lt;a href=&#34;https://gist.github.com/quxiaowei/5440de7c9e2e9b835e5b6225b040a491&#34;&gt;(Gist)&lt;/a&gt;。却发现&lt;code&gt;nested&lt;/code&gt;不见了，查了替代方案记下。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;with&lt;/code&gt; 写法：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;with open(&#39;D:\\input.txt&#39;) as file1:
    with open(&#39;D:\\output.txt&#39; &#39;w+&#39;) as file2:
        for line in file1.readline():
            file2.write(line+&#39;\n&#39;)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;nested()&lt;/code&gt; 写法（&lt;code&gt;caveat&lt;/code&gt;: 已经不可用了）：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;from contextlib import nested

with (open(&#39;D:\\input.txt&#39;), open(&#39;D:\\output.txt&#39;, &#39;w+&#39;)) \
    as (file1, file2):
    
    for line in file1.readline():
        file2.write(line+&#39;\n&#39;)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;新写法：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;from contextlib import ExitStack

with ExitStack() as stack:
    file1 = stack.enter_context(open(&#39;D:\\input.txt&#39;))
    file2 = stack.enter_context(open(&#39;D:\\output.txt&#39;, &#39;w+&#39;))
    for line in file1.readline():
        file2.write(line+&#39;\n&#39;)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;其实对于一两个资源来说，直接用 nested-with 的语法写起来还行，用 ExitStack 看起来就有点啰嗦了。对于多个资源来说，用&lt;code&gt;ExitStack&lt;/code&gt; + &lt;code&gt;list comprehence&lt;/code&gt;写起来倒也不麻烦。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Bilibili 视频抓取脚本</title>
      <link>https://quxiaowei.github.io/post/bilibili_script/</link>
      <pubDate>Tue, 24 May 2016 00:00:00 +0000</pubDate>
      
      <guid>https://quxiaowei.github.io/post/bilibili_script/</guid>
      <description>&lt;p&gt;周末写了个zsh脚本，从B站上下载《不能结婚的男人》，贴上代码。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;for i in {1..12}
do
    url=http://www.bilibili.com/video/av3794937/index_$i.html
    echo $url
    youtube-dl -o &amp;quot;SeGmEnT-$i-%(playlist_index)s.%(ext)s&amp;quot; $url
    rm -f buffer_list
    touch buffer_list
    for file in $(ls SeGmEnT-$i-*.flv)
    do
        echo file &amp;quot;&#39;$file&#39;&amp;quot; &amp;gt;&amp;gt; buffer_list
    done
    ffmpeg -f concat -i buffer_list -c copy $i.mkv 
done
rm -f buffer_list
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>由巴黎恐怖袭击所想到的</title>
      <link>https://quxiaowei.github.io/post/paris_terror_attack/</link>
      <pubDate>Sat, 14 Nov 2015 00:00:00 +0000</pubDate>
      
      <guid>https://quxiaowei.github.io/post/paris_terror_attack/</guid>
      <description>&lt;p&gt;这次巴黎恐怖袭击时间后，我在想，依照以往的舆论发展方向，不久就会出现这样一种说法：恐怖袭击发动者不是真正的穆斯林，真正的穆斯林是热爱和平的。这种言论通常是会获得拥有善意的听众正面的回应的。&lt;/p&gt;

&lt;p&gt;但这种说法是否真的在道理上说的通呢？&lt;/p&gt;

&lt;p&gt;主要有两个问题：&lt;/p&gt;

&lt;p&gt;1.谁是真正的穆斯林？&lt;/p&gt;

&lt;p&gt;在我宗教这种小白看来，无疑存在两种穆斯林：坏的穆斯林，不坏的穆斯林。两边无疑信奉《古兰经》和穆罕默德，两边都认为自己是真正的穆斯林，指责对方不是真正的穆斯林。显然不能指望着从任何一方的嘴中得到答案。大多数善良人们应该和我一样认同不坏的甚至的好的穆斯林了（注意我用的是「认同」）。那究竟是，真正的穆斯林恰好是「不坏」的那个？还是善意影响了我们的判断？很难在这个选择题上得到「客观」的答案。而我却早已给出「好」与「坏」的答案。指导我们作出选择的东西是道德，道德的优先级显然是高于宗教的。而本题的答案是，我们不关心谁是真正的这种问题。谁是坏的我们就要反对谁。&lt;/p&gt;

&lt;p&gt;牵出宗教和道德的问题，总有人说宗教能够规范人的道德，就像我们之前已经基于道德对宗教作出「好」与「坏」的判断，可见道德是早就存在于我们的心里的。而宗教至于道德的作用，正如当代哲学家伯纳德 ·威廉姆斯的一句名言所述 ，是 「多此一举 」（摘自《我们时代的伦理学》）。在我看看来不仅仅是「多此一举」在我看来有时还会起到反作用（基督教历史上也不鲜见）。换句话说，假如宗教教授坏的道德，作为信众能够指责，退出嘛！这显然和某些宗教树立绝对权威是相矛盾而不被允许的。&lt;/p&gt;

&lt;p&gt;2.真正的穆斯林是真实存在的吗？&lt;/p&gt;

&lt;p&gt;在我看来真正的穆斯林并不存在，而只是人们脑中一个概念和善意地一厢情愿。宗教是存在于人们脑中的，每一个信众的行动构成这个宗教的。「好」与「坏」的两方都是遵循《古兰经》的，而显然坏的一方的行为与字面的教诲更为相符，我们都批判教条主义，而基于通一段文本，两种不同阐释我们是无法判断那种是「正宗」那种是「歪曲」的，这两种都是通过人脑加工过产物。我们之所以选择「好」同样也是我们脑中的 道德在起作用，而不是因为「好」的一方更「真正」。&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>