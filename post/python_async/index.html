<!DOCTYPE html>
<html class="no-js" lang="en-US">
    <head>
        <meta charset="utf-8">

        

        <base href="https://quxiaowei.github.io">
		<title>A CodeSmith ⌘</title>
        <link rel="canonical" href="https://quxiaowei.github.io/post/python_async/">
        <link href="" rel="alternate" type="application/rss+xml" title="A CodeSmith ⌘"/>

        
<link rel="stylesheet" href="https://quxiaowei.github.io/css/styles.css">


<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.3.0/katex.min.css">
<script src="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.3.0/katex.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.3.0/contrib/auto-render.min.js"></script>


<script>hljs.initHighlightingOnLoad();</script>

    </head>
    <body>
        <div class="column">

<header class="header">
    <a href="/" class="title">A CodeSmith ⌘</a>
    
</header>


<section id="main">
    <header class="post-header">
      <p class="post-title"><a href="https://quxiaowei.github.io/post/python_async/">㊙️ Python 异步协程 Coroutine </a></p>
      <p class="post-meta">2016 / 7 / 20</p>
    </header>
    <article itemprop="articleBody" id="content">
       <p>tornado 以异步响应为特色，据说是以generator实现的，之前研究过一下，根据原理写了一段简陋的演示代码。3.5 之后 python 增加了async 关键字，就不需要自己实现了。</p>

<p>这段代码意图是 socket 服务器端不断接受，并恢复。有两个关键点：</p>

<ul>
<li>用 decorator 把 generator 封装在 future 里</li>
<li>在 loop 中调用 generator 的 next，send 方法，传递前一步的结果</li>
</ul>

<p>代码比较简陋，各位凑合着看。</p>

<hr />

<p><strong>2016/09/29 更新</strong></p>

<p>最近又在看异步相关的内容，发现自己以前的理解是错误的。内容比较多，可能会单开一篇说下，这里就列出几个我自己理解的错误点、我认为比较关键点。希望对像我一样的学习者有所帮助。</p>

<ol>
<li><p>async | await 关键字，<u>它并不能将同步的代码变成异步</u> ，异步的实现需要异步的库来实现，比如标准的 asyncio 库、tornado、还有 David Beazley 写的一个实验性 curio 库（我目前正在看他的代码）。</p></li>

<li><p>async | await ：关键字只是一个 <strong>接口</strong>，只是一个 <strong>接口</strong>。 就像 yield 定义了 generator， <code>async def</code> 定义一个类型 coroutine factory，它的返回值就是一个 coroutine（叫做 native coroutine 以区别于 3.5 之前的 coroutine ）。await 后面必须是一个 awaitable 的对象，即实现 <code>__await()__</code> 方法的对象，至于这个对象是用 future 还是其他什么东西并不重要。大部分库都是基于类似 future 定义了自己的 task，每家的构建都不同，但本质上就是通过 generator | send 机制
实现的回调机制。</p></li>

<li><p>coroutine | loop ：coroutine 自己不会自己跑起来，那么就需要一个 loop 来返回来管理这些 coroutine ，找到完成的、再回调。易见管理 coroutine 的机制必定和 coroutine 的实现方式紧密耦合，<u>所以各家的 coroutine, task 基本只能和自家的 loop 配套使用</u>。但 <code>asyncio.Future</code> 作为标准库的，基本得到其他家的兼容，或提供了 adaptor 但使用过程并不很友好，时不时会遇到问题。</p></li>

<li><p>需要关注下 <code>yield from</code>， 3.5 之前 <code>yield from</code> 等同于 <code>await</code>。需要关注下两代 coroutine 的区别。这里不细说，详见标准文档。 还有 <code>concurrent.futures.Future</code> 和 <code>asyncio.future</code> 区别，在使用需要注意下，不然很麻烦。</p></li>
</ol>

<p><a href="http://strawhatfy.github.io/2015/07/22/Tornado.gen/">-参考-</a></p>

<script src="//gist.github.com/quxiaowei/0be3d0b20681d8869e8ddffb615fa6d6.js"></script>

<p>『 終 』</p>
    </article>
</section>

<footer class="bottom-footer">
  <div class="copyright">
    <p>
    
    <a href="http://creativecommons.org/licenses/by/4.0/" title="Creative Commons Attribution">Some rights reserved</a>; 
    please attribute properly and link back.
    
    
    </p>
  </div>
</footer>

<script>
    renderMathInElement(document.getElementById('main'));
</script>

</div>
</body>
</html>

