<!doctype html><html lang=en><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><title>A.Smith</title><base href=https://quxiaowei.github.io><link rel="shortcut icon" href=/img/favicon-compact.svg type=image/x-icon><link href=https://quxiaowei.github.io/index.xml rel=alternate type=application/rss+xml title="A CodeSmith"><link rel=stylesheet href=https://quxiaowei.github.io/css/bootstrap.min.css><link rel=stylesheet href=https://quxiaowei.github.io/css/styles.css><link rel=stylesheet href=https://quxiaowei.github.io/css/post.css><link rel=stylesheet href="https://fonts.googleapis.com/css?family=Lobster"><script src=https://cdnjs.cloudflare.com/ajax/libs/jquery/3.2.1/jquery.min.js></script><script src=./script/site.js></script></head><body><div class="column container"><header class=header><a href=/ class=title>A.Smith</a></header><section id=main class=col-md-10><header class=post-header><p class=post-title>Python 异步协程 Coroutine</p><p class=post-meta>2016-7-20</p></header><article itemprop=articleBody id=content><p>tornado 以异步响应为特色，据说是以 generator 实现的，之前简单研究过，根据原理写了一段简陋的演示代码。3.5 之后 python 增加了async 关键字，就不需要自己实现了。这段代码是实现一个异步响应多个链接 socket server。有两个关键点：</p><ul><li>用 decorator 把 generator 封装在 future 里</li><li>在 loop 中调用 generator 的 next，send 方法，传递前一步的结果</li></ul><hr><p><strong>2016/09/29 更新</strong></p><p>最近在重看异步相关的内容，发现以前的理解是错误的。内容比较多，这里列出几个我理解中的错误点 和 我认为的关键点。</p><ol><li><p>async | await 关键字只是一个 <strong>接口</strong>，只是一个 <strong>接口</strong>，它并不能将同步的代码变成异步 ，异步需要其他的库来实现，比如标准的 asyncio 库、tornado、还有 David Beazley 写的一个实验性 curio 库（我目前正在看他的代码）。</p></li><li><p>async def: 就像 yield 催生了 generator 类型， <code>async def</code> 催生了 coroutine 类型（叫做 native coroutine 以区别于 3.5 之前的 coroutine ）。await 后必须跟着一个 awaitable 的对象，即实现 <code>__await()__</code> 方法的对象，至于这个对象是用 future 还是其他什么东西并不重要。大部分库基于类似 future 定义了自己的 task，每家的构建都不同，但实质是通过 generator | send 机制
实现回调。</p></li><li><p>coroutine | loop ：coroutine 不会自己跑起来，需要一个 loop 来管理这些 coroutine ，找到完成的、再穿入上一步的结果来回调。所以管理 loop 必定和 coroutine 的实现方式紧密耦合，所以各家的 task 基本只能和自家的 loop 配套使用。但 <code>asyncio.Future</code> 作为标准库，得到了 tornado 的兼容，并提供了 adaptor。 但使用过程并不十分友好，时不时会遇到问题。</p></li><li><p>另外，需要关注下 <code>yield from</code>， 3.5 之前 <code>yield from</code> 等同于 <code>await</code>。需要关注下两代 coroutine 的区别。这里不细说，详见标准文档。还有需要注意下 <code>concurrent.futures.Future</code> 和 <code>asyncio.future</code> 区别，使用 threadpool 返回的是前者，而前者是不能被 await 的。</p></li></ol><p><a href=http://strawhatfy.github.io/2015/07/22/Tornado.gen/>-参考-</a></p><script type=application/javascript src=https://gist.github.com/quxiaowei/0be3d0b20681d8869e8ddffb615fa6d6.js></script><p>『 終 』</p></article></section><footer class=bottom-footer></footer><script>renderMathInElement(document.getElementById('main'));</script></div><a href=javascript: id=return-to-top><i class=icon-chevron-up></i></a><link href=//netdna.bootstrapcdn.com/font-awesome/3.2.1/css/font-awesome.css rel=stylesheet></body></html>