<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>&lt;/&gt;</title>
    <link>https://quxiaowei.github.io/</link>
    <description>Recent content on &lt;/&gt;</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-cn</language>
    <lastBuildDate>Fri, 22 Jul 2016 00:00:00 +0000</lastBuildDate>
    <atom:link href="https://quxiaowei.github.io/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>Python 写了简单计算器</title>
      <link>https://quxiaowei.github.io/post/python_simple_calculator/</link>
      <pubDate>Fri, 22 Jul 2016 00:00:00 +0000</pubDate>
      
      <guid>https://quxiaowei.github.io/post/python_simple_calculator/</guid>
      <description>&lt;p&gt;看到网上有人问，回想起学校日子，想了一下，实现了一个。没用逆波兰式。很见单没有合法性校验，还必须用空格分隔每个操作符和数字，真是简陋。&lt;/p&gt;

&lt;script src=&#34;//gist.github.com/quxiaowei/ad5846ec6d4a99bb1bdbf5d4a85386c3.js&#34;&gt;&lt;/script&gt;
</description>
    </item>
    
    <item>
      <title>Python 异步协程 Coroutine</title>
      <link>https://quxiaowei.github.io/post/python_async/</link>
      <pubDate>Wed, 20 Jul 2016 00:00:00 +0000</pubDate>
      
      <guid>https://quxiaowei.github.io/post/python_async/</guid>
      <description>&lt;p&gt;tornado 以异步响应为特色，据说是以generator实现的，之前研究过一下，根据原理写了一段简陋的演示代码。3.5 之后 python 增加了async 关键字，就不需要自己实现了。&lt;/p&gt;

&lt;p&gt;这段代码意图是 socket 服务器端不断接受，并恢复。有两个关键点：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;用 decorator 把 generator 封装在 future 里&lt;/li&gt;
&lt;li&gt;在 loop 中调用 generator 的 next，send 方法，传递前一步的结果&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;代码比较简陋，各位凑合着看。&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://strawhatfy.github.io/2015/07/22/Tornado.gen/&#34;&gt;-参考-&lt;/a&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;import socket
from concurrent.futures import ThreadPoolExecutor, as_completed
from collections import deque
from functools import wraps

HOST = &#39;&#39;
PORT = 50007
MAX_CONN = 5
_addr = (HOST, PORT)

s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
s.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)

s.bind(_addr)
s.listen(1)

_pool = {}

executor = ThreadPoolExecutor(max_workers=5)

def asyn(f):
    @wraps(f)
    def wrapper(*args, **kwds):
        handle = f(*args, **kwds)
        _pool[executor.submit(next, handle)] = handle
        return handle
    return wrapper

@asyn
def get_conn():
    if len(_pool) &amp;gt;= MAX_CONN:
        yield False
    conn, addr = s.accept()
    print(&#39;connected&#39;)
    while True:
        print(&#39;before recvievng&#39;)
        data = yield conn.recv(1024)
        print(&#39;after recvievng&#39; )
        data = b&#39;response:&#39;+data
        print(&#39;before sending&#39;)
        yield conn.send(data)
        print(&#39;after sending&#39;)

get_conn()
get_conn()
_handle, _res = 0, 0
while True:
    _t_pool = {}
    for fut, _handle in _pool.items(): 
        if fut.done():
            pass
        else:
            _t_pool[fut] = _handle
            continue
        _handle = _pool[fut]
        _res = fut.result()
        print(&#39;result: %s&#39; % str(_res))
        _t_pool[executor.submit(_handle.send, _res)] = _handle
    _pool = _t_pool

&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>ABAP 调用 RESTful Web Service</title>
      <link>https://quxiaowei.github.io/post/abap_call_restful_webservice/</link>
      <pubDate>Tue, 19 Jul 2016 00:00:00 +0000</pubDate>
      
      <guid>https://quxiaowei.github.io/post/abap_call_restful_webservice/</guid>
      <description>

&lt;blockquote&gt;
&lt;p&gt;哎！一片干的掉渣的文章。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&#34;关于rest&#34;&gt;关于REST&lt;/h2&gt;

&lt;p&gt;REST 是基于 HTTP 的 Web Service 架构，URL 表示资源，HTTP method: GET, POST, DELETE 等等，表示发送，收取，删除等动作。我们是从第三方接收资源，所以用 GET。&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;SOAP 是另一种基于 HTTP 的 Web Service 协议，不在本文范围内。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;以 &lt;code&gt;http://example/credit/20160516/0000001880/1380&lt;/code&gt; 为例，其中 &lt;code&gt;20160516&lt;/code&gt; 代表日期，&lt;code&gt;0000001880&lt;/code&gt; 代表客户，&lt;code&gt;1380&lt;/code&gt; 代表公司，这些作为 Web Service 的参数发给接口。&lt;/p&gt;

&lt;h2 id=&#34;http调用&#34;&gt;HTTP调用&lt;/h2&gt;

&lt;p&gt;ABAP 有许多发送 HTTP GET 请求的方法。我用的是函数: &lt;code&gt;HTTP_GET&lt;/code&gt;。注意设定超时限制，防止网络不通时程序卡死。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-ABAP&#34;&gt;DATA: status(3) TYPE c ,
      url TYPE c LENGTH 200,
      error TYPE string.
        
DATA: response TYPE TABLE OF xtext100 WITH HEADER LINE, &amp;quot; 返回内容
      &amp;quot; HTTP header
      response_headers TYPE TABLE OF text100 WITH HEADER LINE. 
        
url = |http://example/credit/{ p_datum }/{ p_customer }/{ p_company }| .

CALL FUNCTION &#39;HTTP_GET&#39;
  EXPORTING
    absolute_uri          = url    &amp;quot; url
    timeout               = 1      &amp;quot; 超时
  IMPORTING
    status_code           = status  &amp;quot; 200 404等网页状态
  TABLES
    response_entity_body  = response
    response_headers      = response_headers
  EXCEPTIONS
    connect_failed        = 1
    timeout               = 2
    internal_error        = 3
    tcpip_error           = 4
    data_error            = 5
    system_failure        = 6
    communication_failure = 7
    OTHERS                = 8.

IF sy-subrc EQ 0 AND status(1) EQ &#39;2&#39;.
  &amp;quot; 成功
ELSE.
  &amp;quot; 失败
ENDIF.
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;decode&#34;&gt;Decode&lt;/h2&gt;

&lt;p&gt;返回内容的编码可能与 Sap 不兼容，那么需要转码。具体编码信息在 HTTP 头里。
以常见的 UTF-8 为例。&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Decode 代码&lt;/em&gt; ：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-ABAP&#34;&gt;DATA conv TYPE REF TO cl_ABAP_conv_in_ce.
DATA buffer TYPE xstring.
DATA v_text TYPE string.&amp;quot;(100) TYPE c.
DATA v_text_t TYPE string.&amp;quot;(100) TYPE c.
  
conv = cl_ABAP_conv_in_ce=&amp;gt;create( encoding = &#39;UTF-8&#39; ).
LOOP AT response.
  buffer = response.
  TRY.
      conv-&amp;gt;convert(
            EXPORTING input = buffer
            IMPORTING data = v_text_t ).
      CONCATENATE v_text v_text_t INTO v_text.
    CATCH cx_sy_conversion_codepage 
          cx_sy_codepage_converter_init 
          cx_parameter_invalid_type.
      p_subrc = 4.
      p_message = &#39;转码失败！&#39;.
      RETURN.
  ENDTRY.
ENDLOOP.
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;json映射到abap&#34;&gt;JSON映射到ABAP&lt;/h2&gt;

&lt;p&gt;常见的 Web Service 返回格式有 XML 和 JSON 两种。处理 XML 的方法和 JSON 大致相同，只是 “转换”的写法不同。以 JSON 为例：&lt;/p&gt;

&lt;p&gt;&lt;em&gt;JSON 示例&lt;/em&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;[
  {
    &amp;quot;result&amp;quot;:0.0122,
    &amp;quot;errorCode&amp;quot;:&amp;quot;0&amp;quot;,
    &amp;quot;errorMessage&amp;quot;:&amp;quot;&amp;quot;
    }, 
  {
    &amp;quot;result&amp;quot;:2.01,
    &amp;quot;errorCode&amp;quot;:&amp;quot;0&amp;quot;,
    &amp;quot;errorMessage&amp;quot;:&amp;quot;&amp;quot;
  }
]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这是一个包含 2 个对象的数组（&lt;code&gt;[]&lt;/code&gt;表示数组），每个对象（&lt;code&gt;{}&lt;/code&gt;表示对象）中有三个字段： &lt;code&gt;result&lt;/code&gt;, &lt;code&gt;errorCode&lt;/code&gt;, &lt;code&gt;errorMessage&lt;/code&gt;。&lt;code&gt;result&lt;/code&gt;是数字型的（注意没有引号包围），其他均为字符串。&lt;/p&gt;

&lt;p&gt;&lt;em&gt;ABAP 代码&lt;/em&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-ABAP&#34;&gt;TYPES: BEGIN OF ty_result,
        result TYPE string,
        errorcode TYPE string,
        errormessage TYPE string,
       END OF ty_result.
DATA it_result TYPE TABLE OF ty_result.

TRY
    CALL TRANSFORMATION z_test_json1 SOURCE XML v_text
                                     RESULT out = it_result.
  CATCH cx_st_error cx_xslt_exception cx_transformation_error.
    &amp;quot; 解析JSON失败
ENDTRY.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;z_test_json1&lt;/code&gt; 是自定义的 “转换”，将 JSON 中的数据映射到 ABAP 内表或工作区里，因为过程涉及类型转换，所以需要 &lt;code&gt;try catch&lt;/code&gt; 来捕捉异常。“转换”完成后，JSON 中的数据会回填到 &lt;code&gt;it_result&lt;/code&gt; 内表中，整个解析的流程也就完成了。&lt;/p&gt;

&lt;h2 id=&#34;转换-的写法&#34;&gt;“转换”的写法&lt;/h2&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;创建“转换” &lt;img src=&#34;https://quxiaowei.github.io/img/transform1.png&#34; alt=&#34;创建“转换”&#34; /&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;“转换类型”选择“简单转换”&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;“转换”示例&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;pre&gt;&lt;code class=&#34;language-XML&#34;&gt;&amp;lt;?sap.transform simple?&amp;gt;
&amp;lt;tt:transform xmlns:tt=&amp;quot;http://www.sap.com/transformation-templates&amp;quot;&amp;gt;
  &amp;lt;tt:root name=&amp;quot;OUT&amp;quot;/&amp;gt;
  &amp;lt;tt:template&amp;gt;
    &amp;lt;array&amp;gt;
      &amp;lt;tt:loop ref=&amp;quot;.RESULT&amp;quot;&amp;gt;
        &amp;lt;object&amp;gt;
          &amp;lt;num name=&amp;quot;result&amp;quot;&amp;gt;
            &amp;lt;tt:value ref=&amp;quot;$ref.RESULT&amp;quot;/&amp;gt;
          &amp;lt;/num&amp;gt;
          &amp;lt;str name=&amp;quot;errorCode&amp;quot;&amp;gt;
            &amp;lt;tt:value ref=&amp;quot;$ref.ERRORCODE&amp;quot;/&amp;gt;
          &amp;lt;/str&amp;gt;
          &amp;lt;str name=&amp;quot;errorMessage&amp;quot;&amp;gt;
            &amp;lt;tt:value ref=&amp;quot;$ref.ERRORMESSAGE&amp;quot;/&amp;gt;
          &amp;lt;/str&amp;gt;
        &amp;lt;/object&amp;gt;
      &amp;lt;/tt:loop&amp;gt;
    &amp;lt;/array&amp;gt;
  &amp;lt;/tt:template&amp;gt;
&amp;lt;/tt:transform&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;code&gt;&amp;lt;array&amp;gt;&lt;/code&gt; 代表数组，与 JSON 的 &lt;code&gt;[]&lt;/code&gt;对应。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;code&gt;&amp;lt;object&amp;gt;&lt;/code&gt; 代表对象，与 JSON 的 &lt;code&gt;{}&lt;/code&gt;对应。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;code&gt;&amp;lt;tt:loop&amp;gt;&lt;/code&gt; 循环处理多个对象，“转换” 把数据依次 append 到内表中，对于单条数据不需要使用&lt;code&gt;&amp;lt;tt:loop&amp;gt;&lt;/code&gt;。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;code&gt;&amp;lt;num&amp;gt;&lt;/code&gt; &lt;code&gt;&amp;lt;str&amp;gt;&lt;/code&gt; 代表数字、字符串，要与 JSON 的类型对应，否则会报错，如果有非法字符也会报异常，转换过程需要用&lt;code&gt;try catch&lt;/code&gt;来捕捉异常。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;code&gt;&amp;lt;tt:value&amp;gt;&lt;/code&gt; &lt;code&gt;name&lt;/code&gt; 属性与表字段名对应，转换程序会自动将值放到内表或工作区的字段中。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;code&gt;&amp;lt;tt:root&amp;gt;&lt;/code&gt; &lt;code&gt;name&lt;/code&gt; 为“转换”结果（RESULT）的形参名（本例为 out）。&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
&lt;p&gt;JSON 对象内的字段不要求和 ABAP 类型字段顺序一致&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&#34;abap-to-json&#34;&gt;ABAP to JSON&lt;/h2&gt;

&lt;p&gt;我们已经能够将 JSON 映射到 ABAP 里，下面我们试着将 ABAP 再转回 JSON。&lt;/p&gt;

&lt;p&gt;首先，我们将上面的 &lt;code&gt;call transformation&lt;/code&gt; 中的 &lt;code&gt;source&lt;/code&gt; 和 &lt;code&gt;result&lt;/code&gt; 对调，反向使用“转换”。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-ABAP&#34;&gt;CALL TRANSFORMATION z_test_json1 SOURCE out = it_result
                                 RESULT XML = v_text.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;v_text&lt;/strong&gt; :&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-XML&#34;&gt;&amp;lt;?xml version=&amp;quot;1.0&amp;quot; encoding=&amp;quot;utf-16&amp;quot;?&amp;gt;
&amp;lt;array&amp;gt;
  &amp;lt;object&amp;gt;
    &amp;lt;str name=&amp;quot;result&amp;quot;&amp;gt;0.01&amp;lt;/str&amp;gt;
    &amp;lt;str name=&amp;quot;errorCode&amp;quot;&amp;gt;0&amp;lt;/str&amp;gt;
    &amp;lt;str name=&amp;quot;errorMessage&amp;quot;&amp;gt; &amp;lt;/str&amp;gt;
  &amp;lt;/object&amp;gt;
  &amp;lt;object&amp;gt;
    &amp;lt;str name=&amp;quot;result&amp;quot;&amp;gt;2.01&amp;lt;/str&amp;gt;
    &amp;lt;str name=&amp;quot;errorCode&amp;quot;&amp;gt;0&amp;lt;/str&amp;gt;
    &amp;lt;str name=&amp;quot;errorMessage&amp;quot;&amp;gt; &amp;lt;/str&amp;gt;
  &amp;lt;/object&amp;gt;
&amp;lt;/array&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;我们发现 &lt;code&gt;v_text&lt;/code&gt; 里的是 XML，如果需要的是 XML 格式，那么任务已经完成。为了得到 JSON，我们继续做如下修改：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-ABAP&#34;&gt;DATA json_writer TYPE REF TO cl_sxml_string_writer.
json_writer = cl_sxml_string_writer=&amp;gt;create( type = if_sxml=&amp;gt;co_xt_json ).
CALL TRANSFORMATION z_test_json1 SOURCE out = it_result
                                 RESULT XML json_writer. &amp;quot; json_writer.

&amp;quot; Get json-String from writer
DATA json TYPE xstring.
json = json_writer-&amp;gt;get_output( ).
v_text = cl_ABAP_codepage=&amp;gt;convert_from( json ).
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;我们用类型为 co_xt_json 的 sxml_string_writer，将 XML 输出为 JSON 格式。 &lt;strong&gt;注意&lt;/strong&gt; &lt;code&gt;get_output()&lt;/code&gt; 输出的是字节码，要用 &lt;code&gt;cl_abap_codepage=&amp;gt;convert_from( )&lt;/code&gt; 转换成文本。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;v_text&lt;/strong&gt; :&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;[
  {
    &amp;quot;result&amp;quot;:0.01,
    &amp;quot;errorCode&amp;quot;:&amp;quot;0&amp;quot;,
    &amp;quot;errorMessage&amp;quot;:&amp;quot;&amp;quot;
    }, 
  {
    &amp;quot;result&amp;quot;:2.01,
    &amp;quot;errorCode&amp;quot;:&amp;quot;0&amp;quot;,
    &amp;quot;errorMessage&amp;quot;:&amp;quot;&amp;quot;
  }
]
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>FFMPEG Cheatsheet</title>
      <link>https://quxiaowei.github.io/post/ffmpeg_cheatsheet/</link>
      <pubDate>Fri, 15 Jul 2016 00:00:00 +0000</pubDate>
      
      <guid>https://quxiaowei.github.io/post/ffmpeg_cheatsheet/</guid>
      <description>&lt;p&gt;&lt;code&gt;-vcodec&lt;/code&gt; &lt;code&gt;-acodec&lt;/code&gt; 视屏，音频编码 &lt;code&gt;copy&lt;/code&gt; 拷贝源文件&lt;/p&gt;

&lt;p&gt;合并视屏&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;ffmpeg -f concat -i buffer_list -c copy output.mkv
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;截取视频&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;ffmpeg -i source.avi -ss 00:01:35 -t 00:47:13 -vcodec copy output.mp4
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;-ss&lt;/code&gt; 开始时间 &lt;code&gt;-t&lt;/code&gt; 时长&lt;/p&gt;

&lt;p&gt;缩小视屏&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;ffmpeg -i a.mp4 -vf scale=853:480 -acodec acc -vcodec h264 out.mp4
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;裁剪视屏&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;ffmpeg -i a.mp5 -strict -2 -vf crop=1080:1080:0:420 out.mp4
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;crop=width:height:x:y&lt;/code&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Python 的 nested() 不见了</title>
      <link>https://quxiaowei.github.io/post/python_no_nested_anymore/</link>
      <pubDate>Thu, 14 Jul 2016 00:00:00 +0000</pubDate>
      
      <guid>https://quxiaowei.github.io/post/python_no_nested_anymore/</guid>
      <description>&lt;p&gt;最近在和别的系统测试 Rest Web Service 的接口，用 python 写了单元测试脚本 &lt;a href=&#34;https://gist.github.com/quxiaowei/5440de7c9e2e9b835e5b6225b040a491&#34;&gt;(Gist)&lt;/a&gt;。却发现&lt;code&gt;nested&lt;/code&gt;不见了，查了替代方案记下。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;with&lt;/code&gt; 写法：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;with open(&#39;D:\\input.txt&#39;) as file1:
    with open(&#39;D:\\output.txt&#39; &#39;w+&#39;) as file2:
        for line in file1.readline():
            file2.write(line+&#39;\n&#39;)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;nested()&lt;/code&gt; 写法（&lt;code&gt;caveat&lt;/code&gt;: 已经不可用了）：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;from contextlib import nested

with (open(&#39;D:\\input.txt&#39;), open(&#39;D:\\output.txt&#39;, &#39;w+&#39;)) \
    as (file1, file2):
    
    for line in file1.readline():
        file2.write(line+&#39;\n&#39;)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;新写法：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;from contextlib import ExitStack

with ExitStack() as stack:
    file1 = stack.enter_context(open(&#39;D:\\input.txt&#39;))
    file2 = stack.enter_context(open(&#39;D:\\output.txt&#39;, &#39;w+&#39;))
    for line in file1.readline():
        file2.write(line+&#39;\n&#39;)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;其实对于一两个资源来说，直接用 nested-with 的语法写起来还行，用 ExitStack 看起来就有点啰嗦了。对于多个资源来说，用&lt;code&gt;ExitStack&lt;/code&gt; + &lt;code&gt;list comprehence&lt;/code&gt;写起来倒也不麻烦。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Bilibili 视频抓取脚本</title>
      <link>https://quxiaowei.github.io/post/bilibili_script/</link>
      <pubDate>Tue, 24 May 2016 00:00:00 +0000</pubDate>
      
      <guid>https://quxiaowei.github.io/post/bilibili_script/</guid>
      <description>&lt;p&gt;周末写了个zsh脚本，从B站上下载《不能结婚的男人》，贴上代码。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;for i in {1..12}
do
    url=http://www.bilibili.com/video/av3794937/index_$i.html
    echo $url
    youtube-dl -o &amp;quot;SeGmEnT-$i-%(playlist_index)s.%(ext)s&amp;quot; $url
    rm -f buffer_list
    touch buffer_list
    for file in $(ls SeGmEnT-$i-*.flv)
    do
        echo file &amp;quot;&#39;$file&#39;&amp;quot; &amp;gt;&amp;gt; buffer_list
    done
    ffmpeg -f concat -i buffer_list -c copy $i.mkv 
done
rm -f buffer_list
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>由巴黎恐怖袭击所想到的</title>
      <link>https://quxiaowei.github.io/post/paris_terror_attack/</link>
      <pubDate>Sat, 14 Nov 2015 00:00:00 +0000</pubDate>
      
      <guid>https://quxiaowei.github.io/post/paris_terror_attack/</guid>
      <description>&lt;p&gt;这次巴黎恐怖袭击时间后，我在想，依照以往的舆论发展方向，不久就会出现这样一种说法：恐怖袭击发动者不是真正的穆斯林，真正的穆斯林是热爱和平的。这种言论通常是会获得拥有善意的听众正面的回应的。&lt;/p&gt;

&lt;p&gt;但这种说法是否真的在道理上说的通呢？&lt;/p&gt;

&lt;p&gt;主要有两个问题：&lt;/p&gt;

&lt;p&gt;1.谁是真正的穆斯林？&lt;/p&gt;

&lt;p&gt;在我宗教这种小白看来，无疑存在两种穆斯林：坏的穆斯林，不坏的穆斯林。两边无疑信奉《古兰经》和穆罕默德，两边都认为自己是真正的穆斯林，指责对方不是真正的穆斯林。显然不能指望着从任何一方的嘴中得到答案。大多数善良人们应该和我一样认同不坏的甚至的好的穆斯林了（注意我用的是「认同」）。那究竟是，真正的穆斯林恰好是「不坏」的那个？还是善意影响了我们的判断？很难在这个选择题上得到「客观」的答案。而我却早已给出「好」与「坏」的答案。指导我们作出选择的东西是道德，道德的优先级显然是高于宗教的。而本题的答案是，我们不关心谁是真正的这种问题。谁是坏的我们就要反对谁。&lt;/p&gt;

&lt;p&gt;牵出宗教和道德的问题，总有人说宗教能够规范人的道德，就像我们之前已经基于道德对宗教作出「好」与「坏」的判断，可见道德是早就存在于我们的心里的。而宗教至于道德的作用，正如当代哲学家伯纳德 ·威廉姆斯的一句名言所述 ，是 「多此一举 」（摘自《我们时代的伦理学》）。在我看看来不仅仅是「多此一举」在我看来有时还会起到反作用（基督教历史上也不鲜见）。换句话说，假如宗教教授坏的道德，作为信众能够指责，退出嘛！这显然和某些宗教树立绝对权威是相矛盾而不被允许的。&lt;/p&gt;

&lt;p&gt;2.真正的穆斯林是真实存在的吗？&lt;/p&gt;

&lt;p&gt;在我看来真正的穆斯林并不存在，而只是人们脑中一个概念和善意地一厢情愿。宗教是存在于人们脑中的，每一个信众的行动构成这个宗教的。「好」与「坏」的两方都是遵循《古兰经》的，而显然坏的一方的行为与字面的教诲更为相符，我们都批判教条主义，而基于通一段文本，两种不同阐释我们是无法判断那种是「正宗」那种是「歪曲」的，这两种都是通过人脑加工过产物。我们之所以选择「好」同样也是我们脑中的 道德在起作用，而不是因为「好」的一方更「真正」。&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>